### Generar archivo de pruebas 
Cuando se tiene una clase Java (por ejemplo, Calculadora), IntelliJ IDEA ofrece una manera rápida de comenzar a escribir pruebas:
1. Hacer clic derecho sobre el nombre de la clase o el código.
2. Seleccionar Go to → Test o Generate → Test.
3. Elegir JUnit 5 como framework de prueba.
4. IntelliJ generará automáticamente la clase de prueba con la estructura base.

> Esto facilita comenzar con pruebas sin tener que crear manualmente el archivo ni importar dependencias básicas.

### Caso de uso: división en una calculadora

Se desea probar el funcionamiento de una clase `Calculadora` que implementa una operación de división entre dos números reales. En particular, interesa validar que:

- La operación de división devuelva el resultado correcto para valores válidos.
- El método lance una excepción adecuada cuando se intente dividir por cero.

> En este contexto se representa una prueba con sentido al evalúar el comportamiento esperado y el se tratan los errores críticos.

---
### Implementación de la clase a probar

```java
public class Calculadora {

    public double dividir(double dividendo, double divisor) {
        if (divisor == 0) {
            throw new ArithmeticException("No se puede dividir por cero...");
        }
        return dividendo / divisor;
    }
}
```

---
### Estructura de una prueba unitaria con JUnit

  - Inicialmente se utilizará una anotación **@BeforeEach** para inicializar el objeto `Calculadora` antes de la ejecución de cada prueba, lo que evite repetir código en cada método de prueba y asegura que cada prueba se ejecute en un entorno limpio.

  - Luego, para definir cada prueba se usará la anotación **@Test** para marcarla como tal. En este caso, se prueba un escenario exitoso (`testDivisionValida` utilizando un assertEquals) y un escenario de error controlado (`testDivisionPorCero` utilizando assertThrows).

    - **assertEquals:** Verifica que el resultado devuelto por el método sea igual al valor esperado. 
    - **assertThrows:** Comprueba que se lance la excepción adecuada cuando se viola una condición (en este caso, división por cero).

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class CalculadoraTest {

    private Calculadora calculadora;

    @BeforeEach
    public void setUp() {
        calculadora = new Calculadora();
    }

    @Test
    public void testDivisionValida() {
        double resultado = calculadora.dividir(10.0, 2.0);
        assertEquals(5.0, resultado, 0.0001);
    }

    @Test
    public void testDivisionPorCero() {
        assertThrows(ArithmeticException.class, () -> {
            calculadora.dividir(10.0, 0.0);
        });
    }
}
```
---
### Valor de los casos de prueba seleccionados

Los casos de prueba definidos tienen valor porque cubren situaciones reales del uso de una calculadora:

- Validan el cálculo correcto en condiciones normales.
- Evalúan cómo el sistema maneja una operación inválida, previniendo errores en tiempo de ejecución.

Probar estos escenarios asegura que el componente `Calculadora` se comportará de forma predecible tanto en condiciones esperadas como en situaciones límite, garantizando la fiabilidad del sistema completo.
